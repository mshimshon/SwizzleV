"use strict";(self.webpackChunkstatepulse_doc=self.webpackChunkstatepulse_doc||[]).push([[5035],{8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var t=i(6540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},9164:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"What is SwizzleV","title":"What\'s SwizzleV","description":"What is SwizzleV?","source":"@site/docs/What is SwizzleV.md","sourceDirName":".","slug":"/","permalink":"/","draft":false,"unlisted":false,"editUrl":"https://github.com/mshimshon/SwizzleV/docs/What is SwizzleV.md","tags":[{"inline":true,"label":"blazor","permalink":"/tags/blazor"},{"inline":true,"label":"swizzlev","permalink":"/tags/swizzlev"},{"inline":true,"label":"viewmodel-pattern","permalink":"/tags/viewmodel-pattern"},{"inline":true,"label":"component-architecture","permalink":"/tags/component-architecture"},{"inline":true,"label":"dependency-injection","permalink":"/tags/dependency-injection"},{"inline":true,"label":"scoped","permalink":"/tags/scoped"},{"inline":true,"label":"transient","permalink":"/tags/transient"},{"inline":true,"label":"csharp","permalink":"/tags/csharp"},{"inline":true,"label":".net","permalink":"/tags/net"}],"version":"current","sidebarPosition":1,"frontMatter":{"slug":"/","title":"What\'s SwizzleV","tags":["blazor","swizzlev","viewmodel-pattern","component-architecture","dependency-injection","scoped","transient","csharp",".net"],"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Updates","permalink":"/versions"},"next":{"title":"How to Use","permalink":"/how-to-use"}}');var s=i(4848),r=i(8453);const o={slug:"/",title:"What's SwizzleV",tags:["blazor","swizzlev","viewmodel-pattern","component-architecture","dependency-injection","scoped","transient","csharp",".net"],sidebar_position:1},l=void 0,a={},c=[{value:"What is SwizzleV?",id:"what-is-swizzlev",level:2},{value:"What Makes SwizzleV Different?",id:"what-makes-swizzlev-different",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={blockquote:"blockquote",br:"br",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"what-is-swizzlev",children:"What is SwizzleV?"}),"\n",(0,s.jsx)(n.p,{children:"SwizzleV is a lightweight framework for managing ViewModels and encapsulating component behavior in UI applications. It provides clear patterns for defining whether a ViewModel instance should be unique (transient) or shared (scoped), allowing developers to design components with well-contained logic and lifecycle control."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["SwizzleV is ",(0,s.jsx)(n.strong,{children:"not"})," a global state management system.",(0,s.jsx)(n.br,{}),"\n","It focuses on ",(0,s.jsx)(n.strong,{children:"local ViewModel instances"}),", giving developers precise control over behavior without introducing shared application-wide state."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"what-makes-swizzlev-different",children:"What Makes SwizzleV Different?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Precise Lifetime Control:"})," SwizzleV lets you define ViewModels as either transient (per component instance) or scoped (shared across related components). This prevents unintended reuse or leakage."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Framework-Agnostic Design:"})," ViewModels in SwizzleV are not tied to any specific UI framework. They work independently and can be used in Blazor, MAUI, WPF, or any other system that supports C#."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Explicit UI Binding via Interface:"})," Instead of automatic change propagation, SwizzleV uses a simple binding contract:",(0,s.jsx)(n.br,{}),"\n","The ",(0,s.jsx)(n.strong,{children:"consumer"})," (such as a Blazor component) explicitly ",(0,s.jsx)(n.strong,{children:"binds to a ViewModel"}),", implementing an interface that exposes an ",(0,s.jsx)(n.code,{children:"OnChange()"})," method or similar action."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Change Notification via ",(0,s.jsx)(n.code,{children:"SpreadChanges()"}),":"]})," When a ViewModel needs to notify its bound user (UI/s), it calls ",(0,s.jsx)(n.code,{children:"SpreadChanges()"}),", which invokes the consumer\u2019s provided callback. This enables full decoupling from UI frameworks and provides a clean reactive loop ",(0,s.jsx)(n.strong,{children:"without hardwiring"})," to component lifecycles."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.p,{children:["SwizzleV is purpose-built for managing ",(0,s.jsx)(n.strong,{children:"component-level behavior and logic"})," through ViewModels. Its framework-agnostic, opt-in change propagation system gives developers a high degree of flexibility, making it ideal for projects that value ",(0,s.jsx)(n.strong,{children:"modularity"}),", ",(0,s.jsx)(n.strong,{children:"clarity"}),", and ",(0,s.jsx)(n.strong,{children:"UI-framework independence"})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);